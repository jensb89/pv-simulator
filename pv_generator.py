import datetime
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from broker import Broker
import json
import csv

# Definition of a gaussian normal distribution
gauss = (
    lambda mu, sigma, x: 1
    / (sigma * np.sqrt(2 * np.pi))
    * np.exp(-((x - mu) ** 2) / (2 * sigma**2))
)

CSV_FILENAME = "data.csv"


class PVGenerator(object):
    def __init__(self) -> None:
        """
        Constructor of the class.
        It also sets the receive_meter_value() function as the callback
        function for the broker.
        """
        self.data = self.generate_generator_curve()
        self.broker = Broker()
        self.broker.set_receive_callback(self.receive_meter_value)
        # Prepare clean output file
        with open(CSV_FILENAME, "w") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["Time of day","Meter (kW)", "Power from panel (kW)", "Total consumed (kW)"])

    def generate_generator_curve(self, median=86400 * 0.58, deviation=13500, max_val=3.3) -> list:
        """
        This function generates the generator curve.
        In this special case it is approxmiated by a normal distribution around a median value, with a given
        standard deviation.

        :param median: the median of the gaussian curve
        :param deviation: The standard deviation of the gaussian curve, defaults to 13500 (optional)
        :param maxVal: the maximum value of the curve
        :return: A list of values that are the result of the gaussian function for a complete day (86400seconds).
        """
        if median < 0 or median > 86400:
            raise Exception("Median out of boundary (0,86400)")

        data = []
        # one day has 86400 seconds
        for second in range(0, 86400):
            data.append(gauss(median, deviation, second))

        data /= max(data)
        data *= max_val

        return data

    def plot_day_data(self):
        """
        Plot the generated generator curve
        """
        fig, ax = plt.subplots(1)
        fig.autofmt_xdate()

        # TODO/Improvement: Check for same lenght first, or save data together with datetime
        # e.g. in a pandas dataframe or in numpy arrays
        dates = [
            datetime.datetime.now().replace(hour=0, minute=0, second=0)
            + datetime.timedelta(seconds=x)
            for x in range(0, 86400)
        ]
        plt.plot(dates, self.data)

        xfmt = mdates.DateFormatter("%H:%M")
        ax.xaxis.set_major_formatter(xfmt)
        ax.set_xlabel("Time")
        ax.set_ylabel("Power (kw)")
        plt.show()

    def get_data_point(self, date: datetime) -> float:
        """
        The function `get_data_point` takes a `datetime` object
        and returns the corresponding data point from the generator curve for that date.

        :param date: the date you want to get the data point for
        :type date: datetime
        :return: The value of the data point at the given time.
        """
        seconds = date.hour * 60 * 60 + date.minute * 60 + date.second
        value = self.data[seconds]
        return value

    def receive_meter_value(self, ch, method, properties, body) -> None:
        """
        The function receives a message from the RabbitMQ queue, unpacks the json values, extracts the time
        and meter values, gets the corresponding PV value for the time, calculates the total power
        consumption, and appends the time, PV, meter, and total values to the csv file.

        :param ch: the channel object
        :param method: the method frame of the message
        :param properties: a dict of properties that are set on the message
        :param body: the message body
        """
        print(" [x] %r:%r" % (method.routing_key, body))
        # Unpack the json values and extract the time and meter values
        data = json.loads(body)
        time = datetime.datetime.fromisoformat(data.get("time"))
        meterVal = data.get("meterValue") / 1000  # unit:kW
        pv = self.get_data_point(time)  # unit: kW
        total = meterVal - pv  # unit:kW
        self.append_to_csv(time, pv, meterVal, total)

    def append_to_csv(self, time, pv, meter, total) -> None:
        """
        It opens the CSV file, appends a row of data to it, and closes the file

        :param time: The time of the reading
        :param pv: The power generated by the solar panels
        :param meter: The meter reading from the inverter
        :param total: The total power being consumed by the house
        """
        with open(CSV_FILENAME, "a") as csvfile:
            data = [time.strftime("%H:%M:%S"), meter, pv, total]
            writer = csv.writer(csvfile)
            writer.writerow(data)

    def run(self) -> None:
        """
        The `run` function starts the broker receive, which waits for new messages and blocks the shell
        """
        # start the broker receive
        self.broker.receive()


if __name__ == "__main__":
    pv_generator = PVGenerator()
    # pv_generator.plot_day_data()
    pv_generator.run()
